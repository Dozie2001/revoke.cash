import { useAddressEvents } from 'lib/hooks/page-context/AddressPageContext';
import { AllowanceData, Log, ParsedEvent } from 'lib/interfaces';
import ky from 'lib/ky';
import { deduplicateArray } from '.';
import { CHAIN_SELECT_MAINNETS } from './chains';
import { readAndParseContentFile } from './markdown-content';
import { parseLog } from './parse-Approve';

export type Exploit = {
  slug: string;
  name: string;
  description: string;
  longDescription?: string;
  date: string;
  amount: number;
  fixed?: boolean;
  addresses: {
    chainId: number;
    address: string;
  }[];
  metaArticleUrls: string[];
};

const ORGANISATION = 'RevokeCash';
const REPOSITORY = 'approval-exploit-list';
export const REPORT_EXPLOIT_URL = `https://github.com/${ORGANISATION}/${REPOSITORY}/issues/new?assignees=&labels=submission%2Cexploit&projects=&template=REPORT-EXPLOIT.yml`;

export const getAllExploits = async (): Promise<Exploit[]> => {
  const index = (await fetchGithubFile(ORGANISATION, REPOSITORY, '/index.json')) as string[];
  const promises = index.map((slug) => getExploitBySlug(slug));
  const exploits = await Promise.all(promises);

  // sort exploits by date descending
  exploits.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
  return exploits;
};

export const getExploitBySlug = async (slug: string, locale: string = 'en'): Promise<Exploit> => {
  const exploit = (await fetchGithubFile(ORGANISATION, REPOSITORY, `/exploits/${slug}.json`)) as Exploit;
  exploit.slug = slug;

  const short = readAndParseContentFile(['short', slug], locale, 'exploits');
  exploit.description = short?.content && short?.meta.language === locale ? short?.content : exploit.description;

  const long = readAndParseContentFile(['long', slug], locale, 'exploits');
  exploit.longDescription = long?.content && long?.meta.language === locale ? long?.content : null;

  return exploit;
};

export const getGlobalExploitStats = (exploits: Exploit[]) => {
  const totalAmount = formatExploitAmount(Math.floor(exploits.reduce((prev, curr) => prev + curr.amount, 0)));
  const earliestYear = exploits.at(-1).date.slice(0, 4);

  return { totalAmount, earliestYear };
};

const fetchGithubFile = async (organisation: string, repository: string, path: string) => {
  const url = `https://raw.githubusercontent.com/${organisation}/${repository}/main${path}`;

  const text = await ky.get(url).text();

  try {
    return JSON.parse(text);
  } catch {
    return text;
  }
};

export const getUniqueChainIds = (exploit: Exploit): number[] => {
  const sorter = (a: number, b: number) => {
    const indexOfA = CHAIN_SELECT_MAINNETS.indexOf(a);
    const indexOfB = CHAIN_SELECT_MAINNETS.indexOf(b);
    if (indexOfA === -1) return 1;
    if (indexOfB === -1) return -1;
    return indexOfA - indexOfB;
  };

  const allChainIds = exploit.addresses.map((address) => address.chainId);
  const uniqueChainIds = deduplicateArray(allChainIds);
  const sortedChainIds = uniqueChainIds.sort(sorter);

  return sortedChainIds;
};

export const getExploitStatus = (allowances: AllowanceData[], exploit: Exploit) => {
  const { events } = useAddressEvents();
  const parseEvents = (logs: Log[]) => logs.map(parseLog).filter((event): event is ParsedEvent => event !== null);

  const parsedEvents = [
    ...parseEvents(events.approval),
    ...parseEvents(events.approvalForAll),
    ...parseEvents(events.permit2Approval),
  ];

  const isAddressAffected = (parsedEvent: ParsedEvent, exploitAddress: { chainId: number; address: string }) => {
    return (
      parsedEvent.owner === exploitAddress.address &&
      exploitAddress.chainId === allowances.find((a) => a.spender === parsedEvent.spender)?.chainId
    );
  };

  const affected = allowances.some((allowance) => {
    return exploit.addresses.some((exploitAddress) => {
      return (
        exploitAddress.chainId === allowance.chainId &&
        exploitAddress.address === allowance.spender &&
        allowance.amount > 0n
      );
    });
  });

  const previouslyAffected = parsedEvents.some((event) => {
    return exploit.addresses.some((exploitAddress) => isAddressAffected(event, exploitAddress));
  });

  if (affected) {
    return 'affected';
  } else if (previouslyAffected) {
    return 'previously_affected';
  } else {
    return 'safe';
  }
};

export const formatExploitAmount = (amountInMillions: number) => {
  if (amountInMillions === 0) return `$${amountInMillions}`;
  if (amountInMillions < 1) return `$${amountInMillions * 1000}k`;
  return `$${amountInMillions}M`;
};
