'use client';

import { useQuery } from '@tanstack/react-query';
import Loader from 'components/common/Loader';
import {
  useAddressAllowances,
  useAddressEvents,
  useAddressPageContext,
} from 'lib/hooks/page-context/AddressPageContext';
import { getAllowanceKey } from 'lib/utils/allowances';
import { track } from 'lib/utils/analytics';
import { Exploit, getExploitStatus, getParsedEvents } from 'lib/utils/exploits';
import ExploitStatus from './ExploitStatus';

interface Props {
  exploit: Exploit;
}

const ExploitChecker = ({ exploit }: Props) => {
  const { address, selectedChainId } = useAddressPageContext();
  const { allowances, isLoading } = useAddressAllowances();
  const { events } = useAddressEvents();

  // We wrap the status getting in a useQuery mainly so that we can make sure the analytics tracking is handled correctly
  const { data: status } = useQuery({
    queryKey: ['exploit-status', exploit.slug, allowances?.map(getAllowanceKey)],
    queryFn: () => {
      const parsedEvents = [
        ...getParsedEvents(events.approvalForAll),
        ...getParsedEvents(events.approval),
        ...getParsedEvents(events.permit2Approval),
      ];
      //const status = getExploitStatus(allowances, exploit) || 'affected' || 'previously_affected : 'safe';
      const status = getExploitStatus(parsedEvents, allowances, exploit);
      track('Exploit Checked', { exploit: exploit.slug, account: address, chainId: selectedChainId, status });
      return status;
    },
    enabled: !!address && !!allowances && !!selectedChainId,
  });

  if (!address || !selectedChainId) {
    return null;
  }

  return (
    <Loader isLoading={isLoading} className="exploit-checker-loader">
      {/* We use "safe" status as default for formatting the loader */}
      <ExploitStatus status={status ?? 'safe'} exploit={exploit} address={address} chainId={selectedChainId} />
    </Loader>
  );
};

export default ExploitChecker;
